<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Exploring methods to create a multivariate t-distributed random matrix • mvrt</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="Exploring methods to create a multivariate t-distributed random matrix">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">mvrt</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.2.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/mvrt.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="http://github.com/pegeler/mvrt">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Exploring methods to create a multivariate t-distributed random matrix</h1>
                        <h4 class="author">Paul W. Egeler, MS, GStat</h4>
            
            <h4 class="date">2018-04-03</h4>
      
      <small>Source: <a href="http://github.com/pegeler/mvrt/blob/master/vignettes/mvrt.Rmd"><code>vignettes/mvrt.Rmd</code></a></small>

    </div>

    
    
<div class="contents">
<p><em>This document is part of the the <a href="https://github.com/pegeler/mvrt/"><code>mvrt</code> package</a>. See the <a href="https://github.com/pegeler/mvrt/blob/master/README.html">README.md</a> for more information on download and installation.</em></p>
<div id="objective" class="section level2">
<h2 class="hasAnchor">
<a href="#objective" class="anchor"></a>Objective</h2>
<p>The objective of this R package vignette is to investigate the various ways of creating multivariate normal/t distributions. An algorithm using Cholesky decomposition is used; first in R code, then in C++ code. This is compared to existing methods for creating multivariate random matrices, such as <code><a href="http://www.rdocumentation.org/packages/MASS/topics/mvrnorm">MASS::mvrnorm</a></code> and <code><a href="http://www.rdocumentation.org/packages/mvtnorm/topics/Mvt">mvtnorm::rmvt</a></code>.</p>
<p>The matrices are compared using summary statistics and graphics (histograms). The distributions are assessed for “believability”. Methods are also explored for ensuring that the specified correlation/covariance structure is preserved, despite the random process of number generation. Finally, benchmarking is perfromed to determine performance differences.</p>
</div>
<div id="setup" class="section level2">
<h2 class="hasAnchor">
<a href="#setup" class="anchor"></a>Setup</h2>
<div id="defining-the-data" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-the-data" class="anchor"></a>Defining the data</h3>
<p>We will specify the sample n pairs, means, correlation matrix, and variances. The correlation matrix and variances will be used to generate a covariance matrix, which will be used by the random number generator.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="dv">30</span>
mu &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">5</span>,<span class="dv">4</span>)
R &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>,.<span class="dv">9</span>,.<span class="dv">9</span>,<span class="dv">1</span>),<span class="dv">2</span>,<span class="dv">2</span>)
var &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">2.5</span>,<span class="dv">2</span>)

S &lt;-<span class="st"> </span>mvrt<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/mvrt/topics/convert_R2S">convert_R2S</a></span>(R, var)</code></pre></div>
</div>
<div id="defining-the-multivariate-t-distributed-random-matrix-generator-functions" class="section level3">
<h3 class="hasAnchor">
<a href="#defining-the-multivariate-t-distributed-random-matrix-generator-functions" class="anchor"></a>Defining the multivariate t-distributed random matrix generator functions</h3>
<p>First we will define the random number generator functions in R. We will compare the performance of R code with- and without <code class="sourceCode r"><span class="cf">for</span></code> loops. Well-optimized R code may be sufficiently performant as to not warrant the implementation of a compiled alternative.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># With a for loop</span>
mvrt_R_a &lt;-<span class="st"> </span><span class="cf">function</span>(n, mu, S, <span class="dt">df =</span> n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) {

  g.t &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">chol</span>(S))

  bivMat &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">nrow =</span> <span class="kw">length</span>(mu), <span class="dt">ncol =</span> n)

  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_len</span>(n)) {
    bivMat[,i] &lt;-<span class="st"> </span>mu <span class="op">+</span><span class="st"> </span>g.t <span class="op">%*%</span><span class="st"> </span><span class="kw">rt</span>(<span class="kw">length</span>(mu), df)
  }

  <span class="kw">t</span>(bivMat)

}

<span class="co"># Without a for loop</span>
mvrt_R_b &lt;-<span class="st"> </span><span class="cf">function</span>(n, mu, S, <span class="dt">df =</span> n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) {
  
  g &lt;-<span class="st"> </span><span class="kw">chol</span>(S)
  
  random_matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rt</span>(n<span class="op">*</span><span class="kw">length</span>(mu), df),<span class="dt">nrow =</span> <span class="kw">length</span>(mu))
  deviation &lt;-<span class="st"> </span><span class="kw">t</span>(g) <span class="op">%*%</span><span class="st"> </span>random_matrix
  
  <span class="kw">t</span>(mu <span class="op">+</span><span class="st"> </span>deviation)
  
}</code></pre></div>
</div>
<div id="compiling-and-loading-the-c-mvrt-random-matrix-generator" class="section level3">
<h3 class="hasAnchor">
<a href="#compiling-and-loading-the-c-mvrt-random-matrix-generator" class="anchor"></a>Compiling and loading the C++ mvrt random matrix generator</h3>
<p>Next we will load in a function written in C++. The expectation is that the C++ code will be faster than the R code, possibly by several orders of magnitude.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Rcpp<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/Rcpp/topics/sourceCpp">sourceCpp</a></span>(<span class="st">"../src/mvrt.cpp"</span>)</code></pre></div>
<p>The code that was loaded is below.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;RcppArmadillo.h&gt;</span>
<span class="co">// [[Rcpp::depends(RcppArmadillo)]]</span>

using namespace Rcpp;

<span class="co">//' @rdname mvrt</span>
<span class="co">//' @export</span>
<span class="co">// [[Rcpp::export]]</span>
arma::mat mvrt(<span class="dt">int</span> n, arma::vec mu, arma::mat S, <span class="dt">int</span> df=<span class="dv">1</span>)
{

  <span class="co">// Cholesky decomp and transpose covariance matrix</span>
  arma::mat g = chol(S).t();

  <span class="co">// Generate the random data</span>
  arma::vec x_vec = as&lt; arma::vec &gt;( rt(mu.size() * n, df) );
  arma::mat x = arma::mat( (<span class="dt">const</span> <span class="dt">double</span>*)x_vec.begin(), mu.size(), n );

  <span class="co">// Give the random data covariance structure and add mean offset</span>
  x = g * x;
  x.each_col() += mu;

  <span class="cf">return</span> x.t();
}</code></pre></div>
</div>
<div id="define-our-function-for-getting-a-distribution-of-correlation-coefficients" class="section level3">
<h3 class="hasAnchor">
<a href="#define-our-function-for-getting-a-distribution-of-correlation-coefficients" class="anchor"></a>Define our function for getting a distribution of correlation coefficients</h3>
<p>This function will take a function and its arguments and run it a specified number of times, performing a correlation on the output and extracting the off-diagonal element. Essentially, we can use this to run each random number generator an arbitrary number of times and get the Pearson’s correlation for each pair of vectors created. This can be used to examine the distribution of correlation coefficients that can be expected from the random generation processes. Note the random seed parameter which can be set for reproducibility.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">get_cor_dist &lt;-<span class="st"> </span><span class="cf">function</span>(FUN, times, ..., <span class="dt">seed =</span> <span class="dv">999</span>) {
  
  <span class="kw">set.seed</span>(seed)
  
  FUN &lt;-<span class="st"> </span><span class="kw">match.fun</span>(FUN)
  
  my_call &lt;-<span class="st"> </span><span class="kw">as.call</span>(<span class="kw">list</span>(FUN, ...))
  
  out &lt;-<span class="st"> </span><span class="kw">numeric</span>(times)
  
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_len</span>(times)) {
    
    out[i] &lt;-<span class="st"> </span><span class="kw">cor</span>(<span class="kw">eval</span>(my_call))[<span class="dv">2</span>]
    
  }
  
  out
  
}</code></pre></div>
</div>
<div id="generating-the-distributions-of-correlation-coeffiencts-using-sever-random-matrix-generators" class="section level3">
<h3 class="hasAnchor">
<a href="#generating-the-distributions-of-correlation-coeffiencts-using-sever-random-matrix-generators" class="anchor"></a>Generating the distributions of correlation coeffiencts using sever random matrix generators</h3>
<p>Using the function above, we will create similar multivariate t-distributed (or normally-distributed) random matrices using several functions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mvrtRa_dist &lt;-<span class="st">  </span><span class="kw">get_cor_dist</span>(mvrt_R_a, <span class="dv">100</span>, n, mu, S)
mvrtRb_dist &lt;-<span class="st">  </span><span class="kw">get_cor_dist</span>(mvrt_R_b, <span class="dv">100</span>, n, mu, S)
mvrt_dist &lt;-<span class="st">    </span><span class="kw">get_cor_dist</span>(mvrt, <span class="dv">100</span>, n, mu, S, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)  
MASS_dist &lt;-<span class="st">    </span><span class="kw">get_cor_dist</span>(MASS<span class="op">::</span>mvrnorm, <span class="dv">100</span>, n, mu, S)
mvtnorm_dist &lt;-<span class="st"> </span><span class="kw">get_cor_dist</span>(mvtnorm<span class="op">::</span>rmvt, <span class="dv">100</span>, n, S, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)</code></pre></div>
</div>
</div>
<div id="analysis" class="section level2">
<h2 class="hasAnchor">
<a href="#analysis" class="anchor"></a>Analysis</h2>
<div id="checking-the-algorithm" class="section level3">
<h3 class="hasAnchor">
<a href="#checking-the-algorithm" class="anchor"></a>Checking the algorithm</h3>
<div id="homogenous-outputs" class="section level4">
<h4 class="hasAnchor">
<a href="#homogenous-outputs" class="anchor"></a>Homogenous outputs</h4>
<p>First let’s check that our three home-grown functions produce identical results.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> (<span class="kw">identical</span>(mvrtRa_dist, mvrt_dist) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">identical</span>(mvrtRb_dist, mvrt_dist)) {
  <span class="kw">message</span>(<span class="st">"Distributions of correlation coefficients are identical"</span>)
} <span class="cf">else</span> {
  <span class="kw">message</span>(<span class="st">"Distributions of correlation coefficients are NOT identical"</span>)
}</code></pre></div>
<pre><code>## Distributions of correlation coefficients are identical</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> (
  <span class="kw">identical</span>(
    (mvrt_sample &lt;-<span class="st"> </span>{<span class="kw">set.seed</span>(<span class="dv">999</span>); <span class="kw">mvrt</span>(n, mu, S, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)}),
    {<span class="kw">set.seed</span>(<span class="dv">999</span>); <span class="kw">mvrt_R_a</span>(n, mu, S)}
    ) <span class="op">&amp;&amp;</span>
<span class="st">  </span><span class="kw">identical</span>(
    mvrt_sample,
    {<span class="kw">set.seed</span>(<span class="dv">999</span>); <span class="kw">mvrt_R_b</span>(n, mu, S)}
    )
) {
  <span class="kw">message</span>(<span class="st">"Random samples generated match"</span>)
} <span class="cf">else</span> {
  <span class="kw">message</span>(<span class="st">"Random samples generated do NOT match"</span>)
}</code></pre></div>
<pre><code>## Random samples generated match</code></pre>
<p>It appears that we are successful in that the three functions produce identical output. Therefore, we must only examine one function’s output when doing distribution analysis, rather than all three.</p>
</div>
<div id="inspecting-outputted-means-and-variances" class="section level4">
<h4 class="hasAnchor">
<a href="#inspecting-outputted-means-and-variances" class="anchor"></a>Inspecting outputted means and variances</h4>
<p>Let’s run a couple of checks to make sure that the algorithm is at least giving us data with approximately correct means and variances.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Mean mu</span>
<span class="kw">colMeans</span>(<span class="kw">t</span>(<span class="kw">sapply</span>(<span class="kw">lapply</span>(<span class="kw">rep</span>(<span class="dv">30</span>,<span class="dv">100</span>), mvrt, mu, S, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>),colMeans)))</code></pre></div>
<pre><code>## [1] 4.943320 3.951612</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Mean var</span>
<span class="kw">colMeans</span>(<span class="kw">t</span>(<span class="kw">sapply</span>(<span class="kw">lapply</span>(<span class="kw">rep</span>(<span class="dv">30</span>,<span class="dv">100</span>), mvrt, mu, S, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>), apply, <span class="dv">2</span>, var)))</code></pre></div>
<pre><code>## [1] 2.607499 2.103790</code></pre>
<p>Means are close and variances are just a little higher than those specified in the covariance matrix, which we might expect from a relatively small sample size.</p>
</div>
<div id="an-individual-sample" class="section level4">
<h4 class="hasAnchor">
<a href="#an-individual-sample" class="anchor"></a>An individual sample</h4>
<p>Let’s pull a single sample of n = 30. We can check the mean, variance, and correlation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mvrt_sample &lt;-<span class="st"> </span><span class="kw">mvrt</span>(n, mu, S, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)

<span class="kw">colMeans</span>(mvrt_sample)</code></pre></div>
<pre><code>## [1] 5.261327 4.106697</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(mvrt_sample, <span class="dv">2</span>,var)</code></pre></div>
<pre><code>## [1] 2.157964 1.204207</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cor</span>(mvrt_sample)</code></pre></div>
<pre><code>##           [,1]      [,2]
## [1,] 1.0000000 0.8381404
## [2,] 0.8381404 1.0000000</code></pre>
<p>How does a plot of the data look?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(mvrt_sample)
<span class="co"># Regression line</span>
<span class="kw">abline</span>(<span class="kw">lm</span>(mvrt_sample[,<span class="dv">2</span>] <span class="op">~</span><span class="st"> </span>mvrt_sample[,<span class="dv">1</span>]), <span class="dt">col =</span> <span class="st">"red"</span>)

<span class="co"># Center of points</span>
<span class="kw">points</span>(<span class="kw">mean</span>(mvrt_sample[,<span class="dv">1</span>]), <span class="kw">mean</span>(mvrt_sample[,<span class="dv">2</span>]), <span class="dt">col =</span> <span class="st">"blue"</span>, <span class="dt">pch =</span> <span class="dv">22</span>)</code></pre></div>
<p><img src="mvrt_files/figure-html/unnamed-chunk-11-1.png" width="576" style="display: block; margin: auto;"></p>
<p>OK. So we are fairly confident that we are getting the data we requested. Now let’s look at how the correlation coefficients are distributed over several simulations.</p>
</div>
</div>
<div id="comparing-the-correlation-coefficient-distributions-of-the-various-functions" class="section level3">
<h3 class="hasAnchor">
<a href="#comparing-the-correlation-coefficient-distributions-of-the-various-functions" class="anchor"></a>Comparing the correlation coefficient distributions of the various functions</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Summary of the distributions</span>
<span class="kw">summary</span>(mvrt_dist)</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.7809  0.8804  0.9084  0.9043  0.9316  0.9588</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(MASS_dist)</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.7500  0.8831  0.9082  0.9010  0.9219  0.9661</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(mvtnorm_dist)</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.7777  0.8816  0.9030  0.8980  0.9251  0.9570</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Graphical representations</span>
my_hist &lt;-<span class="st"> </span><span class="cf">function</span> (data) {
  <span class="kw">hist</span>(
    data, 
    <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>), 
    <span class="dt">breaks =</span> <span class="st">"fd"</span>, 
    <span class="dt">main =</span> <span class="kw">paste</span>(<span class="st">"Histogram of"</span>,<span class="kw">deparse</span>(<span class="kw">substitute</span>(data))),
    <span class="dt">xlab =</span> <span class="kw">deparse</span>(<span class="kw">substitute</span>(data))
  )
  
  <span class="kw">abline</span>(<span class="dt">v =</span> <span class="fl">0.9</span>, <span class="dt">col =</span> <span class="st">'red'</span>)
}

<span class="kw">my_hist</span>(mvrt_dist)</code></pre></div>
<p><img src="mvrt_files/figure-html/unnamed-chunk-12-1.png" width="576" style="display: block; margin: auto;"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">my_hist</span>(MASS_dist)</code></pre></div>
<p><img src="mvrt_files/figure-html/unnamed-chunk-12-2.png" width="576" style="display: block; margin: auto;"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">my_hist</span>(mvtnorm_dist)</code></pre></div>
<p><img src="mvrt_files/figure-html/unnamed-chunk-12-3.png" width="576" style="display: block; margin: auto;"></p>
</div>
</div>
<div id="guaranteeing-outputs-are-within-a-specified-range" class="section level2">
<h2 class="hasAnchor">
<a href="#guaranteeing-outputs-are-within-a-specified-range" class="anchor"></a>Guaranteeing outputs are within a specified range</h2>
<p>What if we would like to specify that the matrix of values returned is within a reasonable margin to the specified correlation coefficient? This can be done through iterative generation of the random sample with acceptance checks at each step. A matrix norm of the difference in correlation matrices (between generated and specified) may be used as an intuitive check. We may specify that the maximum modulus of the difference between specified and returned correlation matrix elements is below a given threshold.</p>
<p>The determinant may also be used (and is potentially faster). However the norm may be more easily interpreted since the element-wise maximum modulus is a good way for the user to specify an acceptance criterion.</p>
<div id="choosing-the-matrix-norm-over-the-determinant" class="section level3">
<h3 class="hasAnchor">
<a href="#choosing-the-matrix-norm-over-the-determinant" class="anchor"></a>Choosing the matrix norm over the determinant</h3>
<p>Why use the matrix norm rather than the determinant or some other measure? Because it is the most intuitive. The matrix norm is computed several ways. We will use the maximum modulus (absolute value) method, which is equivalent to performing <code class="sourceCode r"><span class="kw">max</span>(<span class="kw">abs</span>())</code> on a matrix. This means that in we can specify the maximum devation of any element within the resultant correlation matrix generated by random sample versus the specified. For example, specifying a maximum matrix norm of 0.05 means that the Pearson’s correlation generated from outputted values will be within <span class="math inline">\(\pm\)</span> 0.05 of the Pearson’s correlation used as the input correlation matrix (as derived form the input covariance matrix).</p>
<p>To demonstrate, we will create a reference correlation matrix and then compare it to a set of contender matrices using the determinant and norm.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># A single reference matrix</span>
R_ref &lt;-<span class="st"> </span>mvrt<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/mvrt/topics/make_cor_mat">make_cor_mat</a></span>(.<span class="dv">9</span>)
R_ref</code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]  1.0  0.9
## [2,]  0.9  1.0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># A set of test matrices</span>
R_test &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="kw">seq</span>(.<span class="dv">5</span>,<span class="dv">1</span>,.<span class="dv">05</span>), mvrt<span class="op">::</span>make_cor_mat)
R_test[[<span class="dv">1</span>]]</code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]  1.0  0.5
## [2,]  0.5  1.0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># What does the determinant look like for the difference matrices?</span>
<span class="kw">sapply</span>(R_test, <span class="cf">function</span>(a,b) <span class="kw">det</span>(a <span class="op">-</span><span class="st"> </span>b), R_ref)</code></pre></div>
<pre><code>##  [1] -0.1600 -0.1225 -0.0900 -0.0625 -0.0400 -0.0225 -0.0100 -0.0025
##  [9]  0.0000 -0.0025 -0.0100</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># And the matrix norm?</span>
<span class="kw">sapply</span>(R_test, <span class="cf">function</span>(a,b) <span class="kw">norm</span>(a <span class="op">-</span><span class="st"> </span>b, <span class="st">"m"</span>), R_ref)</code></pre></div>
<pre><code>##  [1] 0.40 0.35 0.30 0.25 0.20 0.15 0.10 0.05 0.00 0.05 0.10</code></pre>
<p>The user is more likely to understand how to specify a max norm than a max determinant.</p>
</div>
<div id="iterative-function-definitions" class="section level3">
<h3 class="hasAnchor">
<a href="#iterative-function-definitions" class="anchor"></a>Iterative function definitions</h3>
<p>Below we see two function definitions which perform the same task but implement different programming techniques. The first utilizes recursive function calls, while the second uses a <code class="sourceCode r"><span class="cf">for</span></code> loop to repeat sample generation until the acceptance criterion is met.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Using recursive function calls</span>
mvrt_R_c &lt;-<span class="st"> </span><span class="cf">function</span>(n, mu, S, <span class="dt">df =</span> n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">max.norm =</span> <span class="fl">0.05</span>, <span class="dt">type.norm =</span> <span class="st">"m"</span>) {
 
  g &lt;-<span class="st"> </span><span class="kw">chol</span>(S)
 
  random_matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rt</span>(n<span class="op">*</span><span class="kw">length</span>(mu), df),<span class="dt">nrow =</span> <span class="kw">length</span>(mu))
  deviation &lt;-<span class="st"> </span><span class="kw">t</span>(g) <span class="op">%*%</span><span class="st"> </span>random_matrix
 
  out &lt;-<span class="st"> </span><span class="kw">t</span>(mu <span class="op">+</span><span class="st"> </span>deviation)
 
  <span class="cf">if</span> (<span class="kw">norm</span>(<span class="kw">cov2cor</span>(S) <span class="op">-</span><span class="st"> </span><span class="kw">cor</span>(out), <span class="dt">type =</span> type.norm) <span class="op">&lt;=</span><span class="st"> </span>max.norm) {
    <span class="kw">return</span>(out)
  } <span class="cf">else</span> {
    <span class="kw">eval</span>(<span class="kw">match.call</span>())
  }
 
}


<span class="co"># Using the for loop</span>
mvrt_R_d &lt;-<span class="st"> </span><span class="cf">function</span>(
  n,
  mu,
  S,
  <span class="dt">df =</span> n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>,
  <span class="dt">max_norm =</span> <span class="fl">0.05</span>,
  <span class="dt">max_iterations =</span> <span class="dv">1000</span>,
  <span class="dt">type_norm =</span> <span class="st">"m"</span>)
{

  g.t &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">chol</span>(S))

  R_ref &lt;-<span class="st"> </span><span class="kw">cov2cor</span>(S)

  <span class="cf">for</span> (iterations <span class="cf">in</span> <span class="kw">seq_len</span>(max_iterations)) {

    random_matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rt</span>(n<span class="op">*</span><span class="kw">length</span>(mu), df),<span class="dt">nrow =</span> <span class="kw">length</span>(mu))
    deviation &lt;-<span class="st"> </span>g.t <span class="op">%*%</span><span class="st"> </span>random_matrix

    <span class="cf">if</span> (<span class="kw">norm</span>(R_ref <span class="op">-</span><span class="st"> </span><span class="kw">cor</span>(<span class="kw">t</span>(mu <span class="op">+</span><span class="st"> </span>deviation)), <span class="dt">type =</span> type_norm) <span class="op">&lt;=</span><span class="st"> </span>max_norm)
      <span class="kw">return</span>(<span class="kw">t</span>(mu <span class="op">+</span><span class="st"> </span>deviation))

  }

  <span class="kw">stop</span>(
    <span class="st">"Correlation structure with max norm of "</span>, max_norm,
    <span class="st">" was not obtained in "</span>, max_iterations, <span class="st">" iterations"</span>
    )

}</code></pre></div>
<p>We may also include a <code>C++</code> function to achieve this.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Rcpp<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/Rcpp/topics/sourceCpp">sourceCpp</a></span>(<span class="st">"../src/mvrt2.cpp"</span>)</code></pre></div>
<p>The code that was loaded is below.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;RcppArmadillo.h&gt;</span>
<span class="co">// [[Rcpp::depends(RcppArmadillo)]]</span>

using namespace Rcpp;

<span class="co">//' @rdname mvrt</span>
<span class="co">//' @export</span>
<span class="co">// [[Rcpp::export]]</span>
arma::mat mvrt2(
    <span class="dt">int</span> n,
    arma::vec mu,
    arma::mat S,
    <span class="dt">int</span> df=<span class="dv">1</span>,
    <span class="dt">double</span> max_norm=<span class="dv">2</span>,
    <span class="dt">int</span> max_iterations=<span class="dv">1000</span>
  )
{

  <span class="co">// Cholesky decomp and transpose covariance matrix</span>
  arma::mat g = chol(S).t();

  <span class="co">// Get correlation matrix of user-input S matrix</span>
  arma::mat V_sqrt_inv = diagmat(<span class="dv">1</span> / sqrt(S.diag()));
  arma::mat target_cor = V_sqrt_inv * S * V_sqrt_inv;

  <span class="cf">for</span> (<span class="dt">int</span> iteration=<span class="dv">0</span>; iteration &lt; max_iterations; iteration++)
  {

    <span class="co">// Generate the random data</span>
    arma::vec x_vec = as&lt; arma::vec &gt;( rt(mu.size() * n, df) );
    arma::mat x = arma::mat( (<span class="dt">const</span> <span class="dt">double</span>*)x_vec.begin(), mu.size(), n );

    <span class="co">// Give the random data covariance structure and add mean offset</span>
    x = g * x;
    x.each_col() += mu;

    <span class="co">// Compare to target and retrun if meets specification</span>
    arma::mat diff_matrix = abs(cor(x.t()) - target_cor);

    <span class="cf">if</span> (diff_matrix.max() &lt;= max_norm) <span class="cf">return</span> x.t();

  }

  stop(
    <span class="st">"Did not generate matrix with max norm of %f in %i iterations"</span>,
    max_norm,
    max_iterations
  );

}</code></pre></div>
</div>
<div id="checking-our-work" class="section level3">
<h3 class="hasAnchor">
<a href="#checking-our-work" class="anchor"></a>Checking our work</h3>
<p>Now lets see if the distributions tighten up with our new functions. We should now see that the correlation coefficient of each of our randomly generated samples will not stray more than 0.05 from the correlation of the correlation matrix used to specify the covariance structure of the data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mvrtRc_dist &lt;-<span class="st">  </span><span class="kw">get_cor_dist</span>(mvrt_R_c, <span class="dv">100</span>, n, mu, S)
mvrtRd_dist &lt;-<span class="st">  </span><span class="kw">get_cor_dist</span>(mvrt_R_d, <span class="dv">100</span>, n, mu, S)
mvrt2_dist &lt;-<span class="st">   </span><span class="kw">get_cor_dist</span>(mvrt2,    <span class="dv">100</span>, n, mu, S, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, <span class="fl">0.05</span>)

<span class="cf">if</span> (<span class="kw">identical</span>(mvrtRc_dist, mvrtRd_dist) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">identical</span>(mvrtRc_dist, mvrt2_dist)) {
  <span class="kw">message</span>(<span class="st">"Distributions of correlation coefficients are identical"</span>)
} <span class="cf">else</span> {
  <span class="kw">message</span>(<span class="st">"Distributions of correlation coefficients are NOT identical"</span>)
}</code></pre></div>
<pre><code>## Distributions of correlation coefficients are identical</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(mvrtRc_dist)</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.8545  0.8801  0.9070  0.9028  0.9257  0.9472</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">my_hist</span>(mvrtRc_dist)</code></pre></div>
<p><img src="mvrt_files/figure-html/unnamed-chunk-17-1.png" width="576" style="display: block; margin: auto;"></p>
<p>This appears to have worked. Compare with distributions explored in the previous section.</p>
<p>We can also specify a different covariance structure and check again. This demonstrates the usage of the various function definitions we have created for this exercise.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(
  <span class="kw">get_cor_dist</span>(
    mvrt_R_d, 
    <span class="dv">100</span>, 
    n, 
    mu, 
    mvrt<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/mvrt/topics/convert_R2S">convert_R2S</a></span>(mvrt<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/mvrt/topics/make_cor_mat">make_cor_mat</a></span>(<span class="fl">0.2</span>),var)
    )
  )</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.1502  0.1727  0.2059  0.2012  0.2254  0.2500</code></pre>
<p>Not surprisingly, the correlation coefficients remain within [0.15,0.25].</p>
</div>
</div>
<div id="benchmarking" class="section level2">
<h2 class="hasAnchor">
<a href="#benchmarking" class="anchor"></a>Benchmarking</h2>
<p>Let’s see how the functions compare in speed.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">microbenchmark<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/microbenchmark/topics/microbenchmark">microbenchmark</a></span>(
  <span class="co"># No data checks</span>
  <span class="kw">mvrt_R_a</span>(n, mu, S),               <span class="co"># 'for' loop</span>
  <span class="kw">mvrt_R_b</span>(n, mu, S),               <span class="co"># Optimized R code</span>
  <span class="kw">mvrt</span>(n, mu, S, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>),            <span class="co"># C++ code</span>
  
  <span class="co"># Iterative checking</span>
  <span class="kw">mvrt_R_c</span>(n, mu, S),               <span class="co"># Recursive call</span>
  <span class="kw">mvrt_R_d</span>(n, mu, S),               <span class="co"># 'for' loop</span>
  <span class="kw"><a href="../reference/mvrt.html">mvrt2</a></span>(n, mu, S, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, <span class="fl">0.05</span>),     <span class="co"># C++ code</span>
  
  <span class="co"># Available packages on CRAN</span>
  MASS<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/MASS/topics/mvrnorm">mvrnorm</a></span>(n, mu, S),
  mvtnorm<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/mvtnorm/topics/Mvt">rmvt</a></span>(n, S, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">+</span><span class="st"> </span>mu
)</code></pre></div>
<pre><code>## Unit: microseconds
##                             expr     min       lq      mean   median
##               mvrt_R_a(n, mu, S)  73.118  79.8330  85.53380  83.2860
##               mvrt_R_b(n, mu, S)  20.265  23.6490  26.62688  25.5575
##            mvrt(n, mu, S, n - 1)   9.516  11.9185  13.56137  13.7675
##               mvrt_R_c(n, mu, S)  46.752  54.5880  70.53956  60.6215
##               mvrt_R_d(n, mu, S)  52.844  58.7705  85.45690  64.5535
##     mvrt2(n, mu, S, n - 1, 0.05)  10.755  14.4040  17.07289  15.9395
##          MASS::mvrnorm(n, mu, S)  51.484  63.4195  67.71284  66.2470
##  mvtnorm::rmvt(n, S, n - 1) + mu 204.635 216.7585 225.16570 221.8460
##        uq      max neval
##   87.9110  113.261   100
##   28.5385   59.406   100
##   14.7660   21.463   100
##   70.1820  174.048   100
##   71.3050 1533.552   100
##   18.9240   31.579   100
##   69.7340  124.292   100
##  229.6160  286.630   100</code></pre>
<p>I know the <code class="sourceCode r"><span class="op">::</span></code> operator has a performance cost for those CRAN packages. It may be interesting to try the benchmarking with loaded packages, too.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">MASS_mvrnorm &lt;-<span class="st"> </span>MASS<span class="op">::</span>mvrnorm
mvtnorm_rmvt &lt;-<span class="st"> </span>mvtnorm<span class="op">::</span>rmvt

microbenchmark<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/microbenchmark/topics/microbenchmark">microbenchmark</a></span>(
  MASS<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/MASS/topics/mvrnorm">mvrnorm</a></span>(n, mu, S),
  <span class="kw">MASS_mvrnorm</span>(n, mu, S),
  mvtnorm<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/mvtnorm/topics/Mvt">rmvt</a></span>(n, S, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">+</span><span class="st"> </span>mu,
  <span class="kw">mvtnorm_rmvt</span>(n, S, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">+</span><span class="st"> </span>mu
)</code></pre></div>
<pre><code>## Unit: microseconds
##                             expr     min       lq      mean   median
##          MASS::mvrnorm(n, mu, S)  49.243  57.5085  73.79916  66.1565
##           MASS_mvrnorm(n, mu, S)  42.783  52.5385  63.01251  56.5635
##  mvtnorm::rmvt(n, S, n - 1) + mu 195.604 204.1195 249.19622 216.1355
##   mvtnorm_rmvt(n, S, n - 1) + mu 186.588 198.6790 249.02270 211.5220
##        uq      max neval
##   81.1200  173.933   100
##   70.4090  107.845   100
##  267.6580  473.439   100
##  252.0095 1423.917   100</code></pre>
</div>
<div id="conclusion" class="section level2">
<h2 class="hasAnchor">
<a href="#conclusion" class="anchor"></a>Conclusion</h2>
<p>Clearly, rolling your own C++ code is superior. But given the performance gain from removing the <code class="sourceCode r"><span class="cf">for</span></code> loop from our original R function, optimization of R code cannot be underestimated. Given that the well-written R code is comparably performant within an order of magnitude, the switch to C++ is likely not worth the additional effort in this case.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#objective">Objective</a></li>
      <li><a href="#setup">Setup</a></li>
      <li><a href="#analysis">Analysis</a></li>
      <li><a href="#guaranteeing-outputs-are-within-a-specified-range">Guaranteeing outputs are within a specified range</a></li>
      <li><a href="#benchmarking">Benchmarking</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Paul Egeler.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
